#### 1. JAVA IO流的概念、分类、类图

##### 1.1 JAVA IO流的概念

 java的io是实现输入和输出的基础，可以方便的实现数据的输入和输出操作。在java中把不同的输入/输出源（键盘，文件，网络连接等）抽象表述为“流”(stream)。通过流的形式允许java程序使用相同的方式来访问不同的输入/输出源。stram是从起源（source）到接收的（sink）的有序数据。

> 注：java把所有的传统的流类型都放到在java io包下，用于实现输入和输出功能。

##### 1.2 IO流的分类

按照不同的分类方式，可以把流分为不同的类型。常用的分类有三种:

###### **1.2.1 按照流的流向分，可以分为输入流和输出流。**

- 输入流： 只能从中读取数据，而不能向其写入数据。

- 输出流：只能向其写入数据，而不能向其读取数据。

  此处的输入,输出涉及一个方向的问题，对于如图15.1所示的数据流向，数据从内存到硬盘，通常称为输出流——也就是说，这里的输入，输出都是从程序运行所在的内存的角度来划分的。

  ![image-20201023162214732](C:\Users\hena14758\AppData\Roaming\Typora\typora-user-images\image-20201023162214732.png)

###### **1.2.2 按照操作单元划分，可以划分为字节流和字符流。**

 字节流和字符流的用法几乎完成全一样，区别在于字节流和字符流所操作的数据单元不同，字节流操作的单元是数据单元是8位的字节，字符流操作的是数据单元为16位的字符。

> 字节流主要是由InputStream和outPutStream作为基类，而字符流则主要有Reader和Writer作为基类。

###### **1.2.3 按照流的角色划分为节点流和处理流。**

可以从/向一个特定的IO设备（如磁盘，网络）读/写数据的流，称为节点流。节点流也被称为低级流。图15.3显示了节点流的示意图。
    从图15.3中可以看出，当使用节点流进行输入和输出时，程序直接连接到实际的数据源，和实际的输入/输出节点连接。
处理流则用于对一个已存在的流进行连接和封装，通过封装后的流来实现数据的读/写功能。处理流也被称为高级流。

当使用处理流进行输入/输出时，程序并不会直接连接到实际的数据源，没有和实际的输入和输出节点连接。使用处理流的一个明显的好处是，只要使用相同的处理流，程序就可以采用完全相同的输入/输出代码来访问不同的数据源，随着处理流所包装的节点流的变化，程序实际所访问的数据源也相应的发生变化。

![image-20201023162438120](C:\Users\hena14758\AppData\Roaming\Typora\typora-user-images\image-20201023162438120.png)

##### 1.3 流的原理浅析和常用的流的分类表

###### 1.3.1 流的原理浅析

 java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java Io流的40多个类都是从如下4个抽象类基类中派生出来的。

- **InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。**
- **OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。**

   对于InputStream和Reader而言，它们把输入设备抽象成为一个”水管“，这个水管的每个“水滴”依次排列，如图15.5所示：
    从图15.5可以看出，字节流和字符流的处理方式其实很相似，只是它们处理的输入/输出单位不同而已。输入流使用隐式的记录指针来表示当前正准备从哪个“水滴”开始读取，每当程序从InputStream或者Reader里面取出一个或者多个“水滴”后，记录指针自定向后移动；除此之外，InputStream和Reader里面都提供了一些方法来控制记录指针的移动。

![image-20201023162643168](C:\Users\hena14758\AppData\Roaming\Typora\typora-user-images\image-20201023162643168.png)

对于OutputStream和Writer而言，它们同样把输出设备抽象成一个”水管“，只是这个水管里面没有任何水滴，如图15.6所示：

![image-20201023162721128](C:\Users\hena14758\AppData\Roaming\Typora\typora-user-images\image-20201023162721128.png)

   正如图15.6所示，当执行输出时，程序相当于依次把“水滴”放入到输出流的水管中，输出流同样采用隐示指针来标识当前水滴即将放入的位置，每当程序向OutputStream或者Writer里面输出一个或者多个水滴后，记录指针自动向后移动。
   图15.5和图15.6显示了java Io的基本概念模型，除此之外，Java的处理流模型则体现了Java输入和输出流设计的灵活性。处理流的功能主要体现在以下两个方面。

- 性能的提高：主要以增加缓冲的方式来提供输入和输出的效率。
- 操作的便捷：处理流可能提供了一系列便捷的方法来一次输入和输出大批量的内容，而不是输入/输出一个或者多个“水滴”。

    处理流可以“嫁接”在任何已存在的流的基础之上，这就允许Java应用程序采用相同的代码，透明的方式来访问不同的输入和输出设备的数据流。图15.7显示了处理流的模型。

![image-20201023162740649](C:\Users\hena14758\AppData\Roaming\Typora\typora-user-images\image-20201023162740649.png)

###### 1.3.2 java输入/输出流体系中常用的流的分类表

> **注：表中粗体字所标出的类代表节点流，必须直接与指定的物理节点关联：斜体字标出的类代表抽象基类，无法直接创建实例。**

| **分类**        | 字节输入流               | **字节输出流**            | **字符输入流**      | **字符输出流**      |
| --------------- | ------------------------ | :------------------------ | ------------------- | ------------------- |
| <u>抽象基类</u> | *InputStream*            | *OutputStream*            | *Reader*            | *Writer*            |
| 访问文件        | **FileInputStream**      | **FileOutputStream**      | **FileReader**      | **FileWriter**      |
| 访问数组        | **ByteArrayInputStream** | **ByteArrayOutputStream** | **CharArrayReader** | **CharArrayWriter** |
| 访问管道        | **PipedInputStream**     | **PipedOutputStream**     | **PipedReader**     | **PipedWriter**     |
| 访问字符串      |                          |                           | **StringReader**    | **StringWriter**    |
| 缓冲流          | BufferedInputStream      | BufferedOutputStream      | BufferedReader      | BufferedWriter      |
| 转换流          |                          |                           | InputStreamReader   | OutputStreamWriter  |
| 对象流          | ObjectInputStream        | ObjectOutputStream        |                     |                     |
| <u>抽象基类</u> | *FilterInputStream*      | *FilterOutputStream*      | *FilterReader*      | *FilterWriter*      |
| 打印流          |                          | PrintStream               |                     | PrintWriter         |
| 推回输入流      | PushbackInputStream      |                           | PushbackReader      |                     |
| 特殊流          | DataInputStream          | DataOutputStream          |                     |                     |

#### 2.常用的io流的用法

下面是整理的常用的Io流的特性及使用方法，只有清楚每个Io流的特性和方法。才能在不同的需求面前正确的选择对应的IO流进行开发。

InputStream和Reader是所有输入流的抽象基类，本身并不能创建实例来执行输入，但它们将成为所有输入流的模板，所以它们的方法是所有输入流都可使用的方法。
在InputStream里面包含如下3个方法。

- int read(); 从输入流中读取单个字节（相当于从图15.5所示的水管中取出一滴水），返回所读取的字节数据（字节数据可直接转换为int类型）。
- int read(byte[] b)从输入流中最多读取b.length个字节的数据，并将其存储在字节数组b中，返回实际读取的字节数。
- int read(byte[] b,int off,int len); 从输入流中最多读取len个字节的数据，并将其存储在数组b中，放入数组b中时，并不是从数组起点开始，而是从off位置开始，返回实际读取的字节数。

在Reader中包含如下3个方法。

- int read(); 从输入流中读取单个字符（相当于从图15.5所示的水管中取出一滴水），返回所读取的字符数据（字节数据可直接转换为int类型）。

- int read(char[] b)从输入流中最多读取b.length个字符的数据，并将其存储在字节数组b中，返回实际读取的字符数。

- int read(char[] b,int off,int len); 从输入流中最多读取len个字符的数据，并将其存储在数组b中，放入数组b中时，并不是从数组起点开始，而是从off位置开始，返回实际读取的字符数。

  对比InputStream和Reader所提供的方法，就不难发现这两个基类的功能基本是一样的。InputStream和Reader都是将输入数据抽象成如图15.5所示的水管，所以程序即可以通过read()方法每次读取一个”水滴“，也可以通过read（char[] chuf）或者read（byte[] b）方法来读取多个“水滴”。当使用数组作为read（）方法中的参数, 我们可以理解为使用一个“竹筒”到如图15.5所示的水管中取水，如图15.8所示read(char[] cbuf)方法的参数可以理解成一个”竹筒“，程序每次调用输入流read(char[] cbuf)或read（byte[] b）方法，就相当于用“竹筒”从输入流中取出一筒“水滴”，程序得到“竹筒”里面的”水滴“后，转换成相应的数据即可；程序多次重复这个“取水”过程，直到最后。程序如何判断取水取到了最后呢？直到read（char[] chuf）或者read（byte[] b）方法返回-1，即表明到了输入流的结束点。

  ![image-20201023165019813](C:\Users\hena14758\AppData\Roaming\Typora\typora-user-images\image-20201023165019813.png)

InputStream和Reader提供的一些移动指针的方法：

- void mark(int readAheadLimit); 在记录指针当前位置记录一个标记（mark）。
- boolean markSupported(); 判断此输入流是否支持mark()操作，即是否支持记录标记。
- void reset(); 将此流的记录指针重新定位到上一次记录标记（mark）的位置。
- long skip(long n); 记录指针向前移动n个字节/字符。

OutputStream和Writer：
OutputStream和Writer的用法也非常相似，它们采用如图15.6所示的模型来执行输入，两个流都提供了如下三个方法：

- void write(int c); 将指定的字节/字符输出到输出流中，其中c即可以代表字节，也可以代表字符。
- void write(byte[]/char[] buf); 将字节数组/字符数组中的数据输出到指定输出流中。
- void write(byte[]/char[] buf, int off,int len ); 将字节数组/字符数组中从off位置开始，长度为len的字节/字符输出到输出流中。

因为字符流直接以字符作为操作单位，所以Writer可以用字符串来代替字符数组，即以String对象作为参数。Writer里面还包含如下两个方法。

- void write(String str); 将str字符串里包含的字符输出到指定输出流中。

- void write (String str, int off, int len); 将str字符串里面从off位置开始，长度为len的字符输出到指定输出流中。

  

#### 3. 何为NIO，与传统IO有何区别

    我们使用InputStream从输入流中读取数据时，如果没有读取到有效的数据，程序将在此处阻塞该线程的执行。其实传统的输入里和输出流都是阻塞式的进行输入和输出。 不仅如此，传统的输入流、输出流都是通过字节的移动来处理的（即使我们不直接处理字节流，但底层实现还是依赖于字节处理），也就是说，面向流的输入和输出一次只能处理一个字节，因此面向流的输入和输出系统效率通常不高。
    从JDk1.4开始，java提供了一系列改进的输入和输出处理的新功能，这些功能被统称为新IO(NIO)。新增了许多用于处理输入和输出的类，这些类都被放在java.nio包及其子包下，并且对原io的很多类都以NIO为基础进行了改写。新增了满足NIO的功能。
    NIO采用了内存映射对象的方式来处理输入和输出，NIO将文件或者文件的一块区域映射到内存中，这样就可以像访问内存一样来访问文件了。通过这种方式来进行输入/输出比传统的输入和输出要快的多。

**JDk1.4使用NIO改写了传统Io后，传统Io的读写速度和NIO差不了太多。**

#### 4. 在开发中正确使用Io流

    了解了java io的整体类结构和每个类的一下特性后，我们可以在开发的过程中根据需要灵活的使用不同的Io流进行开发。下面是我整理2点原则:

- 如果是操作二进制文件那我们就使用字节流，如果操作的是文本文件那我们就使用字符流。
- 尽可能的多使用处理流，这会使我们的代码更加灵活，复用性更好。

#### 5. IO模型

##### 5.1 基本概念

- 同步&&异步

  同步：如果有多个任务或者事件要发生，这些任务或者事件必须逐个地进行，一个事件或者任务的执行会导致整个流程的暂时等待，这些事件没有办法并发地执行；

  异步：如果有多个任务或者事件发生，这些事件可以并发地执行，一个事件或者任务的执行不会导致整个流程的暂时等待。

  这就是同步和异步。举个简单的例子，假如有一个任务包括两个子任务A和B，对于同步来说，当A在执行的过程中，B只有等待，直至A执行完毕，B才能执行；而对于异步就是A和B可以并发地执行，B不必等待A执行完毕之后再执行，这样就不会由于A的执行导致整个任务的暂时等待。

- 阻塞&&非阻塞

  阻塞：当某个事件或者任务在执行过程中，它发出一个请求操作，但是由于该请求操作需要的条件不满足，那么就会一直在那等待，直至条件满足；

  非阻塞：当某个事件或者任务在执行过程中，它发出一个请求操作，如果该请求操作需要的条件不满足，会立即返回一个标志信息告知条件不满足，不会一直在那等待。

  这就是阻塞和非阻塞的区别。也就是说阻塞和非阻塞的区别关键在于当发出请求一个操作时，如果条件不满足，是会一直等待还是返回一个标志信息。

- 阻塞IO&&非阻塞IO

  在阻塞模式下，若从网络流中读取不到指定大小的数据量，阻塞IO就在那里阻塞着。比如，已知后面会有10个字节的数据发过来，但是我现在只收到8个字节，那么当前线程就在那傻傻地等到下一个字节的到来，对，就在那等着，啥事也不做，直到把这10个字节读取完，这才将阻塞放开通行。

  在非阻塞模式下，若从网络流中读取不到指定大小的数据量，非阻塞IO就立即通行。比如，已知后面会有10个字节的数据发过来，但是我现在只收到8个字节，那么当前线程就读取这8个字节的数据，读完后就立即返回，等另外两个字节再来的时候再去读取。

- 同步IO&&异步IO

   在同步文件IO中，线程启动一个IO操作然后就立即进入等待状态，直到IO操作完成后才醒来继续执行。而异步文件IO方式中，线程发送一个IO请求到内核，然后继续处理其他的事情，内核完成IO请求后，将会通知线程IO操作完成了。

  同步过程中进程触发IO操作并等待或者轮询的去查看IO操作是否完成。异步过程中进程触发IO操作以后，直接返回，做自己的事情，IO交给内核来处理，完成后内核通知进程IO完成

##### 5.2 常见的IO模型

网络IO操作实际过程涉及到内核和调用这个IO操作的进程。以read为例，read的具体操作分为以下两个部分:

（1）内核等待数据可读（2）将内核读到的数据拷贝到进程

1. 阻塞IO模型

   ![image-20201023172549712](C:\Users\hena14758\AppData\Roaming\Typora\typora-user-images\image-20201023172549712.png)

   当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。对于networkio来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候kernel（内核）就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。

   所以，blockingIO的特点就是在IO执行的两个阶段都被block了。

2. 非租塞IO模型

   ![image-20201023172619704](C:\Users\hena14758\AppData\Roaming\Typora\typora-user-images\image-20201023172619704.png)

   从图中可以看出，当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的systemcall，那么它马上就将数据拷贝到了用户内存，然后返回。

   所以，等待数据的过程变为非阻塞，用户进程其实是需要不断的主动询问kernel（内核）数据好了没有。

   所以事实上，在非阻塞IO模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞IO不会交出CPU，而会一直占用CPU。

   但是对于非阻塞IO就有一个非常严重的问题，在while循环中需要不断地去询问内核数据是否就绪，这样会导致CPU占用率非常高，因此一般情况下很少使用while循环这种方式来读取数据。

3. 多路复用IO模型

   ![image-20201023172831093](C:\Users\hena14758\AppData\Roaming\Typora\typora-user-images\image-20201023172831093.png)

   当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。

    这个图和blockingIO的图其实并没有太大的不同，事实上还更差一些。因为这里需要使用两个系统调用(select和recvfrom)，而blockingIO只调用了一个系统调用(recvfrom)。但是，用select的优势在于它可以同时处理多个connection。（所以，如果处理的连接数不是很高的话，使用select/epoll的webserver不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。

   ​     在IO multiplexingModel中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socketIO给block。 


   　　  相比非阻塞IO模型，在多路复用IO模型中，会有一个线程不断去轮询多个socket的状态（因为在多路复用IO模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，所以它大大减少了资源占用）。

   　　 另外多路复用IO为何比非阻塞IO模型的效率高是因为在非阻塞IO中，不断地询问socket状态是通过用户线程去进行的，而在多路复用IO中，轮询每个socket状态是内核在进行的，这个效率要比用户线程要高的多。

4. 信号驱动IO模型

   类似观察者。在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用IO读写操作来进行实际的IO请求操作。

5. 异步IO模型

   ![image-20201023173358695](C:\Users\hena14758\AppData\Roaming\Typora\typora-user-images\image-20201023173358695.png)

   异步IO模型才是最理想的IO模型，在异步IO模型中，当用户线程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它收到一个asynchronousread之后，它会立刻返回，说明read请求已经成功发起了，因此不会对用户线程产生任何block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它read操作完成了（即两个阶段任务完成），然后可以直接去使用数据了。

    也就说在异步IO模型中，IO操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。这点也是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用IO函数进行实际的读写操作（需要先将数据从kernel拷贝到用户进程）；而在异步IO模型中，收到信号表示IO操作已经完成（即两步操作完成），不需要再在用户线程中调用IO函数进行实际的读写操作。

   　　 注意，异步IO是需要操作系统的底层支持，在Java7中，提供了Asynchronous IO。

   　　 前面四种IO模型实际上都属于同步IO，只有最后一种是真正的异步IO，因为无论是多路复用IO还是信号驱动模型，IO操作的第2个阶段都会引起用户线程阻塞，也就是内核进行数据拷贝的过程都会让用户线程阻塞。