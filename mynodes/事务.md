### 事务

#### 事务隔离级别

##### 1.**ISOLATION_DEFAULT(一般情况下使用这种配置既可)**

这是一个PlatfromTransactionManager默认的隔离级别，使用数据库默认的事务隔离级别。

##### 2.**ISOLATION_READ_UNCOMMITTED**

这是事务最低的隔离级别，它充许别外一个事务可以看到这个事务未提交的数据。这种隔离级别会产生脏读，不可重复读和幻像读。

(大部分数据库缺省的事物隔离级别都不会出现这种状况)

##### 3.**ISOLATION_READ_COMMITTED** 

保证一个事务修改的数据提交后才能被另外一个事务读取。另外一个事务不能读取该事务未提交的数据。这种事务隔离级别可以避免脏读出现，但是可能会出现不可重复读和幻像读。

(大部分数据库缺省的事物隔离级别都不会出现这种状况)

##### **4. ISOLATION_REPEATABLE_READ** 

这种事务隔离级别可以防止脏读，不可重复读。但是可能出现幻像读。

(大部分数据库缺省的事物隔离级别都不会出现这种状况)

##### **5. ISOLATION_SERIALIZABLE**

这是花费最高代价但是最可靠的事务隔离级别。事务被处理为顺序执行。除了防止脏读，不可重复读外，还避免了幻读。

#### 脏读

什么是脏读？

例如：

张三的工资为5000,事务A中把他的工资改为8000,但事务A尚未提交。

与此同时，

事务B正在读取张三的工资，读取到张三的工资为8000。

随后，

事务A发生异常，而回滚了事务。张三的工资又回滚为5000。

最后，

事务B读取到的张三工资为8000的数据即为脏数据，事务B做了一次脏读。

#### 不可重复读

例如：

在事务A中，读取到张三的工资为5000，操作没有完成，事务还没提交。

与此同时，

事务B把张三的工资改为8000，并提交了事务。

随后，

在事务A中，再次读取张三的工资，此时工资变为8000。在一个事务中前后两次读取的结果并不致，导致了不可重复读。

(大部分数据库缺省的事物隔离级别都不会出现这种状况)

#### 幻读

例如:

目前工资为5000的员工有10人，事务A读取所有工资为5000的人数为10人。

此时，

事务B插入一条工资也为5000的记录。

这是，事务A再次读取工资为5000的员工，记录为11人。此时产生了幻读。

(大部分数据库缺省的事物隔离级别都会出现这种状况，此种事物隔离级别将带来表级锁)

说 明 ：Oracle数据库缺省的事物隔离级别已经保证了避免脏读和不可重复读。但可能会幻读，避免幻读需要加表级锁，Oracle缺省行级锁。在基于 Spring的事物配置中一定要慎重使用ISOLATION_SERIALIZABLE的事物隔离级别。这种配置会使用表级锁，对性能影响巨大。一般没有 特殊需要的话，配置为使用数据库缺省的事物隔离级别便可。

